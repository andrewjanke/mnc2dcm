#! /usr/bin/env perl
#
# A simple DICOM dumper
#
# Copyright Andrew Janke - a.janke@gmail.com
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies.  The
# author makes no representations about the suitability of this software
# for any purpose.  It is provided "as is" without express or implied warranty.

$| = 1;

#use strict;
use warnings "all";
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use Cwd;

use DICOM;
use DICOM::Fields;
use DICOM::Element;

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.0.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';

my($me, %opt, @command, $script);

$me = &basename($0);
%opt = (verbose => 0,
        fake => 0,
        man => 0,
        help => 0,
        move => 0,
        );

# Get the history string
chomp($history = `date`);
$history .= '>>>> ' . join(' ', $me, @ARGV) . "\n";

# Check arguments
&GetOptions(
   'help|?' => \$opt{'help'},
   'man' => \$opt{'man'},
   'v|verbose' => \$opt{'verbose'},
   'version' => sub { &print_version_info },
   'f|fake' => \$opt{'fake'},
   'move' => \$opt{'move'},
   ) or pod2usage(-verbose => 1) && exit;
   
# handle -man, -help or missing args
pod2usage(-verbose => 1) if $opt{help};
pod2usage(-exitstatus => 0, -verbose => 2) if $opt{man};
pod2usage(-verbose => 0) && exit if ($#ARGV < 0);

# get the input file and fill er up.
@infiles = ();
foreach $f (@ARGV){
   # if a file
   if(-f $f){
      push(@infiles, $f);
      next;
      }
   
   # if a directory
   if(-d $f){
      @buf = split(/\n/, `find $f -type f`);
      push(@infiles, @buf);
      next;
      }
   
   die "This is bad - $f probably doesn't exist\n";
   }

# create the DICOM object
my $d = DICOM->new();

print "Reading $#infiles Images:";
foreach $infile (@infiles){
   
   # fill the DICOM object
   $d->fill($infile);

   #print "CONTENTS ($infile)\n";
   #$d->printContents();
   
   # Series, Acquisition, Image IDS
   $StudyID = $d->value('0020', '0010');
   $SeriesNumber = $d->value('0020', '0011');
   $AcquisitionNumber = $d->value('0020', '0012');
   $ImageNumber = $d->value('0020', '0013');
   
   # clean up numbers
   $StudyID =~ s/\ //g;
   $SeriesNumber *= 1;
   $AcquisitionNumber *= 1;
   $ImageNumber *= 1;
   
   # print "[$infile:$StudyID] S:$SeriesNumber A:$AcquisitionNumber I:$ImageNumber\n";
   
   # hunt for a patient name or ID
   $PatientName = $d->value('0010', '0010');
   $PatientID = $d->value('0010', '0020');
   
   $ID = "$PatientID\_$PatientName-$StudyID";
   
   $ID =~ s/\^/\-/g;
   $ID =~ s/\ //g;
   $ID = lc($ID);
   
   # print "PN: $ID\n";
   
   # enter the filename
   $db{$ID}{$SeriesNumber}{$AcquisitionNumber}{$ImageNumber} = $infile;
   
   # times
   $StudyDate = $d->value('0008', '0020');
   $SeriesDate = $d->value('0008', '0021');
   $SeriesTime = $d->value('0008', '0031');
   $AcquisitionTime = $d->value('0008', '0032');
   $ImageTime = $d->value('0008', '0033');
   
  # print "[$infile:$ID] $StudyDate $SeriesDate $SeriesTime $AcquisitionTime $ImageTime\n";
   
   $StudyDate{$ID} = $StudyDate;
   $SeriesDate{"$ID:$SeriesNumber"} = $SeriesDate;
   
   if(defined($SeriesTime{"$ID:$SeriesNumber"}) && 
      $SeriesTime{"$ID:$SeriesNumber"} != $SeriesTime){
      print "ERROR! Series Time does not match($infile)";
      #exit(1);
      }
   $SeriesTime{"$ID:$SeriesNumber"} = $SeriesTime;
   $AcquisitionTime{"$ID:$SeriesNumber:$AcquisitionNumber"} = $AcquisitionTime;
   $ImageTime{"$ID:$SeriesNumber:$AcquisitionNumber:$ImageNumber"} = $ImageTime;
   
   # Sequence, Protocol Name
   $SequenceName = $d->value('0018', '0024');
   $ProtocolName = $d->value('0018', '1030');
   $SequenceName =~ s/\ $//g;
   $ProtocolName =~ s/\ $//g;
   
   $SequenceName{"$ID:$SeriesNumber"} = $SequenceName;
   $ProtocolName{"$ID:$SeriesNumber"} = $ProtocolName;
  # print "[$infile:$ID] [$SeriesNumber][$AcquisitionNumber][$ImageNumber] - $SequenceName - $ProtocolName\n";
  
   print '.';
   }
print "Done\n";


#(0008, 0020) DA      8: StudyDate                         = 20090218
#(0008, 0021) DA      8: SeriesDate                        = 20090219
#(0008, 0022) DA      8: AcquisitionDate                   = 20090219
#(0008, 0023) DA      8: ImageDate                         = 20090219

#(0008, 0030) TM     14: StudyTime                         = 142540.687000 
#(0008, 0031) TM     14: SeriesTime                        = 134047.437000 
#(0008, 0032) TM     14: AcquisitionTime                   = 134110.150000 
#(0008, 0033) TM     14: ImageTime                         = 134111.921000 


#(0020, 0010) SH      8: StudyID                           = 5150440 
#(0020, 0011) IS      2: SeriesNumber                      = 30
#(0020, 0012) IS      2: AcquisitionNumber                 = 9 
#(0020, 0013) IS      2: ImageNumber                       = 9 


# print out the database

foreach $id (sort {$a <=> $b} (keys(%db))){

   foreach $ser (sort {$a <=> $b} (keys(%{$db{$id}}))){

      print "[$id][" . sprintf("%03d", $ser) . 
            '][' . $SeriesDate{"$id:$ser"} . 
            '][' . $SeriesTime{"$id:$ser"} . 
            '] '. $ProtocolName{"$id:$ser"} . 
            ' ';

      print "   ";
      foreach $acq (sort {$a <=> $b} (keys(%{$db{$id}{$ser}}))){

         #print "   Acq[" . $AcquisitionTime{"$ID:$s:$a"} . "]: $a  (";
         print "$acq ";

         @imgs = (sort {$a <=> $b} (keys(%{$db{$id}{$ser}{$acq}})));

         print '(' . join(' ', @imgs) . ') ' if($#imgs > 0);
         
         if($opt{'move'}){
            foreach $img (@imgs){
               
               $infile = $db{$id}{$ser}{$acq}{$img};
               
               $protocol = $ProtocolName{"$id:$ser"};
               $protocol =~ s/\//\-/g;
               $protocol =~ s/\ /\-/g;
               $outdir = "$id/" . sprintf("%04d", $ser) . "_$protocol";
               $outfile = sprintf("%04d-%04d.dcm", $acq, $img);
               
            #   print "$infile => $outdir/$outfile\n";
               
               &do_cmd('mkdir', '-p', $outdir);
               &do_cmd('mv', '-i', $infile, "$outdir/$outfile");
               }
            }
         }
      print "\n";
      }
   }


sub do_cmd { 
   print STDOUT "@_\n" if $opt{verbose};
   if(!$opt{fake}){
      system(@_) == 0 or die;
      }
   }

sub print_version_info {
   print STDOUT "\n$PACKAGE version $VERSION\n".
                "Comments to $PACKAGE_BUGREPORT\n\n";
   exit;
   }


__END__

=head1 NAME

B<dcmsort> - sort a directory of dicom files

=head1 SYNOPSIS

B<dcmsort> [options] infile1.dcm [ infile2.dcm [ indir1 ] ]

dcmsort will take an input series of dicom files (or directories), 
find all the dicom files in there and then make an output directory
structure in the current directory using the paitient ID and sequence
names as subfolders.

   $ dcmsort 2312323/*.dcm 

or

   $ dcmsort 2312323
   
Will achieve the same thing. 


=head1 DESCRIPTION

B<dcmsort> digs in the headers of each dicom file in the input list and
builds a database of the series, acquisision and image's. From there it
will output the individual dicom files into a more sensical structure
that will allow the easy conversion of just one series. Note that at this
stage no real sanity checking of the input dicom files is done such as
checking for missing images and mismatched headers.

By default dcmsort will just output a listing of what is in the input
dicom files, if you want it to really move the files in question use
the --move option.

Problems or comments should not be sent to: a.janke@gmail.com he really
is not all that interested in maintaining things that pertain to DICOM
as it seems to be a constantly moving target. But hey you can
still email and you might just get lucky, he might be having a good day.

=head1 OPTIONS

=over 4

=item B<-v>, B<--verbose>

Be noisy(er) when doing things

=item B<--version>

Print version number and exit

=item B<-h>, B<--help>

Dump some quick help output

=item B<--man>

Dump a man page

=item B<-f>, B<--fake>

Do a dry run. This is usually only useful if combined with --verbose so that you can see what is going on.

=item B<--move>

Move the input files 

=back

=head1 SEE ALSO

DICOM.pm

=head1 AUTHOR

Andrew Janke - a.janke@gmail.com

=cut
