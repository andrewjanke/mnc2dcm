#! /usr/bin/env perl
#
# A simple MINC to Dicom converter
#
# Copyright Andrew Janke - a.janke@gmail.com
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies.  The
# author makes no representations about the suitability of this software
# for any purpose.  It is provided "as is" without express or implied warranty.


#use strict;
use warnings "all";
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use File::Temp qw/ tempdir /;
use Cwd;

use DICOM;
use DICOM::Fields;
use DICOM::Element;

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.0.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';

my($me, %opt, @command, $script);

$me = &basename($0);
%opt = (verbose => 0,
        fake => 0,
        man => 0,
        help => 0,
        );

# Get the history string
chomp($history = `date`);
$history .= '>>>> ' . join(' ', $me, @ARGV) . "\n";

# Check arguments
&GetOptions(
   'help|?' => \$opt{'help'},
   'man' => \$opt{'man'},
   'v|verbose' => \$opt{'verbose'},
   'version' => sub { &print_version_info },
   'f|fake' => \$opt{'fake'},
   ) or pod2usage(-verbose => 1) && exit;
   
# handle -man, -help or missing args
pod2usage(-verbose => 1) if $opt{help};
pod2usage(-exitstatus => 0, -verbose => 2) if $opt{man};
pod2usage(-verbose => 0) && exit if ($#ARGV != 1);

# get arguments
$infile = $ARGV[0];
$outdir = $ARGV[1];

# set up tmpdir
$opt{tmpdir} = &tempdir( "$me-XXXXXXXX", TMPDIR => 1, CLEANUP => 1 );

# initialise the dictionary using defaults
foreach my $line (@dicom_fields) {
   next if ($line =~ /^\#/);
   my ($group, $elem, $code, $numa, $name) = split(/\s+/, $line);
   my @lst = ($code, $name);
   $dict{$group}{$elem} = [@lst];
   }

# check for infile
if(!-e $infile){
   die "$me: Couldn't find input file: $infile\n\n";
   }

# make outdir if it doesn't exist
if(!-e $outdir){
   &do_cmd('mkdir', '-p', $outdir);
   }

# create out dicom structure
my $d = DICOM->new();

# SeriesNumber (set to zero which may or may not be a good idea! -- time will tell)
$d->{'0020'}{'0011'} = &create_element('0020', '0011', 0);

# Series time
$d->{'0008'}{'0031'} = &create_element('0008', '0031', "1200");

# Sequence name
$d->{'0018'}{'1030'} = &create_element('0018', '1030', "testy-bob");

# Image Comment
$d->{'0020'}{'4000'} = &create_element('0020', '4000', "Created by $me ($VERSION)");


# reshape the image to zyx
print STDOUT "+ Reshaping $infile to zyx +dir\n";
&do_cmd('mincreshape', '-clobber',
        '-dimorder', 'zspace,yspace,xspace',
        '+direction',
        '-dimsize', 'xspace=-1',
        '-dimsize', 'yspace=-1',
        '-dimsize', 'zspace=-1',
        $infile, "$opt{'tmpdir'}/res.mnc");

# Get sizes
@args = ('mincinfo', '-error_string', 0,
         '-dimlength', 'xspace', '-dimlength', 'yspace', '-dimlength', 'zspace',
         "$opt{'tmpdir'}/res.mnc");
$args = join(' ', @args);
@data = split(/\n/, `$args`);
($xsize, $ysize, $zsize) = @data[0..2];


# first create the required elements (setting to null and/or 0)
$d->{'0020'}{'0013'} = &create_element('0020', '0013', 0);
$d->{'7FE0'}{'0010'} = &create_element('7FE0', '0010', 0);


# for each slice
foreach $s (0..($zsize-1)){
   
   $outfile = "$outdir/$s.dcm";
   
   print STDOUT "  | Working on slice $s\n";
   
   # set the image number
   $d->setElementValue('0020', '0013', $s);
   
   # get and set the slice
   $data = `mincextract -byte -start $s,0,0 -count 1,$ysize,$xsize $opt{'tmpdir'}/res.mnc`;
   $d->{'7FE0'}{'0010'}->{'value'} = "fred";
   
   # write the file out
   $d->write($outfile);
   }


# debug rooting
#$d->fill("minimal.dcm");


print "CONTENTS: \n";
foreach $c ($d->contents()){
   
   print "C: $c\n";
   
   my @arr = @{$c};
   
   $gp = $arr[0];
   $el = $arr[1];
   
   print "   [$gp][$el] - " . join(" | ", @arr[2..5]) . "\n" . 
         "                - $arr[6]\n";
   }

# write the image out
#$d->write($outfile);
#$pixels = $d->value('7FE0', '0010');
#open(FH, ">raw");
#print FH $pixels;
#close(FH);



# create and element, fill in the missing bits 
# from the dictionary and set its value
sub create_element {
   
   ($gr, $el, $val) = @_;
   
   # create the new element
   my $n = DICOM::Element->new();
   
   # set the group and element ids
   $n->{'group'} = $gr;
   $n->{'element'} = $el;
   
   # get the element type and name from the data dictionary
   ($n->{'code'}, $n->{'name'}) = @{$dict{$gr}{$el}};
   
   # set the offset to zero for now
   $n->{'offset'} = 0;
   
   # set the value
   $n->setValue($val);
   
   return $n;
   }


sub do_cmd { 
   print STDOUT "@_\n" if $opt{verbose};
   if(!$opt{fake}){
      system(@_) == 0 or die;
      }
   }

sub print_version_info {
   print STDOUT "\n$PACKAGE version $VERSION\n".
                "Comments to $PACKAGE_BUGREPORT\n\n";
   exit;
   }


__END__

=head1 NAME

B<mnc2dcm> - simple MINC to Dicom converter

=head1 SYNOPSIS

B<mnc2dcm> [options] in.mnc out_base

mnc2dcm should work to convert 3D MINC volumes to Dicom "format". By
Dicom format I mean as much to spec as possible. Mind you this in
NO WAY means that you will be able to re-import these images into some
scanner interface as most of these have their own addittions to Dicom
that are not always that compatible with each other. So yes your images
might be importable into such scanner interfaces but also might not.

They should howver be easily readable with Dicom viewers such as Osirix,
Sante Dicom Viewer and ImageJ (three of the viewers on which the output
of mnc2dcm has been tested).

   $ mnc2dcm <in.mnc> <outdir>

=head1 DESCRIPTION

B<mnc2dcm> is a bit of a hack really though as all it does is call ...

 eg:
    $ mnc2dcm <in.mnc> <outdir>

Problems or comments should not be sent to: a.janke@gmail.com he really
is not all that interested in maintaining things that pertain to DICOM
as it seems to be a constantly moving target. But hey you can
still email and you might just get lucky, he might be having a good day.

=head1 OPTIONS

=over 4

=item B<-v>, B<--verbose>

Be noisy when doing things (most importantly this will echo the resulting script to the terminal)

=item B<--version>

Print version number and exit

=item B<-h>, B<--help>

Dump some quick help output

=item B<--man>

Dump a man page

=item B<-f>, B<--fake>

Do a dry run. This is usually only useful if combined with --verbose so that you can see what is going on.

=back

=head1 SEE ALSO

dconvert(1)

=head1 AUTHOR

Andrew Janke - a.janke@gmail.com

=cut
