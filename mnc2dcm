#! /usr/bin/env perl
#
# Andrew Janke - a.janke@gmail.com
#
#
# A simple MINC to Dicom converter

use strict;
use warnings "all";
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use Cwd;

use DICOM

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.0.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';
 
my($me, %opt, @command, $script);

# Check arguments
&GetOptions(
   'help|?' => \$opt{'help'},
   'man' => \$opt{'man'},
   'v|verbose' => \$opt{'verbose'},
   'version' => sub { &print_version_info },
   'f|fake' => \$opt{'fake'},
   'q|queue=s' => \$opt{'queue'},
   'N|name=s' => \$opt{'jname'},
   'd|depends=s' => \$opt{'depends'},
   'l|logfile=s' => \$opt{'logfile'}
   ) or pod2usage(-verbose => 1) && exit;




my %sequences;
my $elements = DICOM->new();
my %seq_dirs = ();

sub usage {
	print "$prog -- Dicom Organizer and Converter\n";
	print "Alexandre Carmel-Veilleux <acveilleux\@mrs.mni.mcgill.ca>\n";
	print "\nUsage:\n";
	print "\t$prog -m [ -o output_dir ] input_dir\n";
	print "\t$prog -s [ -o output_dir ] input_dir\n\n";
	print "Flags:\n";
	print "\t-m\tConvert to minc directly\n";
	print "\t-s\tSort out the DICOM file and rename them\n\n";
}

sub scan_dir {
	my $dir = shift;
	@dicoms = ();
	
	print "Opening Dir \"$dir\"\n";

	opendir DIR, $dir;

	while (my $file = readdir DIR) {
		my $marker;
		$file = "$dir/$file";

		print "Checking $file...";

		open DICM, "$file";
		sysseek DICM, 128, SEEK_SET;
		sysread DICM, $marker, 4;
		close DICM;
	
		if ($marker eq "DICM") {
			print "DICOM File";
			push @dicoms, $file;
		}

		print "\n";
	}

	close DIR;

	reverse @dicoms;
}

sub sort_dicoms {
	while (my $dicom = shift @dicoms) {
		my ($series_number, $image_number, $temporal_position,
			$seq_name, $series_time) = undef;

		$elements->fill($dicom);

		$series_number = $elements->value('0020', '0011');
		$image_number = $elements->value('0020', '0013');
		$temporal_position = $elements->value('0020', '0100');
		$seq_name = $elements->value('0018', '1030');
		$series_time = $elements->value('0008', '0031');

		$series_time =~ s/[^0-9.]//g;
		$series_number =~ s/[^0-9]//g;
		$image_number =~ s/[^0-9]//g;
		$temporal_position =~ s/[^0-9]//g;

		print "$dicom is $series_time"."_$series_number"."_$seq_name image #$image_number\n";

		if (defined($series_number) && $series_number > 0) {
			$sequences{$series_time."_".$series_number}->{$seq_name}->{$temporal_position}->{$image_number} = $dicom;
		} else {
			print "ERROR: $series_time"."_$series_number $seq_name slice $image_number\n";
		}
	}
}

sub copy_dicoms {
	my $input_dir = shift;
	my $output_dir;

	if ($opts{'o'}) {
		$output_dir = $opts{'o'};
	} else {
		$output_dir = $input_dir;
	}

	if (! -e $output_dir) {
		mkdir $output_dir;
	}

	foreach my $seq (keys %sequences) {
		print "SEQUENCE: $seq\n";
		foreach my $seq_name (keys %{$sequences{$seq}}) {
			foreach my $tempos (keys %{$sequences{$seq}->{$seq_name}}) {
				print "TEMPORAL POSITION: $tempos\n";
				foreach my $img (keys %{$sequences{$seq}->{$seq_name}->{$tempos}}) {	
					print "IMAGE: $img\n";
					my $path = $seq."_".$seq_name;
					my $fname = "$img.dcm";

					$path =~ s/[ \/]/_/g;
					$path = "$output_dir/$path";
					$path .= "_$tempos";

					if (! -e "$path") {
						mkdir "$path";
					}
					$seq_dirs{"$path"} = 1;

					$path .= "/$fname";

					print "copy $sequences{$seq}->{$seq_name}->{$tempos}->{$img}, $path;\n";

					copy "$sequences{$seq}->{$seq_name}->{$tempos}->{$img}", "$path";
				}
			}
		}
	}
}

sub convert_dicoms {
	my $cwd = getcwd;

	foreach my $dir (keys %seq_dirs) {
		chdir $dir;
		system("dicom_to_minc . *");
		chdir $cwd;
	}
}

$prog = $0;
$prog =~ s/[^\/]*\///g;

if (!getopts('mso:', \%opts)) {
	print STDERR "Error: Invalid Argument.\n";
	usage;
	exit 1;
}

if ((!$opts{'m'}) && (!$opts{'s'})) {
	print STDERR "Error: Either -m or -s must be specified.\n";
	usage;
	exit 1;
}

if (!defined($ARGV[0])) {
	print STDERR "Error: You must provide and input_dir.\n";
	usage;
	exit 1;
}

scan_dir $ARGV[0];
sort_dicoms;
copy_dicoms $ARGV[0]; 
if ($opts{'m'}) {
	convert_dicoms;
}
